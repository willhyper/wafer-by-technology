
import tsmc as data
import numpy as np
from scipy.optimize import minimize, nnls, LinearConstraint

quarters = data.quarters()

def _iter_to_array(it):
    return np.array(list(it))

def _revenue_of_tech(tech): 
    return _iter_to_array(data.revenue_of_technology(tech).values())/1000  # M NTD to B NTD

revenue_matrix = np.array(
    [
        _revenue_of_tech('5nm'),
        _revenue_of_tech('7nm'),
        _revenue_of_tech('10nm'),
        _revenue_of_tech('16nm'),
        _revenue_of_tech('20nm'),
        _revenue_of_tech('28nm'),
        _revenue_of_tech('40/45nm'),
        _revenue_of_tech('65nm'),
        _revenue_of_tech('90nm'),
        _revenue_of_tech('0.11/0.13um'),
        _revenue_of_tech('0.15/0.18um'),
        _revenue_of_tech('0.25um+'),
    ])
''' # Revenue (B NTD): technology (5nm, 7nm, ...) by quarters (2021Q1, 2020Q4, 2020Q3, ...)
array([
       [ 50.7374,  72.306 ,  28.5144,   0.    ,   0.    ,   0.    , 0.    ,   0.    ,   0.    ,   0.    ,   0.    ,   0.    , 0.    ],
       [126.8435, 104.8437, 124.7505, 111.852 , 108.71  , 111.034 , 79.1235,  50.61  ,  48.114 ,  66.6471,  28.6385,   0.    , 0.    ],
       [  0.    ,   0.    ,   0.    ,   0.    ,   1.553 ,   3.1724, 5.861 ,   7.23  ,   8.748 ,  17.3862,  15.621 ,  30.3264, 47.1352],
       [ 50.7374,  46.9989,  64.1574,  55.926 ,  59.014 ,  63.448 , 64.471 ,  55.43  ,  34.992 ,  57.954 ,  59.8805,  48.9888, 44.6544],
       [  0.    ,   3.6153,   3.5643,   3.107 ,   3.106 ,   3.1724, 2.9305,   2.41  ,   2.187 ,   2.8977,   5.207 ,   9.3312, 9.9232],
       [ 39.8651,  39.7683,  42.7716,  43.498 ,  43.484 ,  41.2412, 46.888 ,  43.38  ,  43.74  ,  49.2609,  49.4665,  53.6544, 49.616 ],
       [ 25.3687,  28.9224,  28.5144,  27.963 ,  31.06  ,  25.3792, 29.305 ,  26.51  ,  26.244 ,  28.977 ,  31.242 ,  25.6608, 27.2888],
       [ 18.1205,  18.0765,  17.8215,  18.642 ,  18.636 ,  22.2068, 20.5135,  19.28  ,  17.496 ,  23.1816,  20.828 ,  20.9952, 22.3272],
       [ 10.8723,   7.2306,   7.1286,   9.321 ,   9.318 ,   9.5172, 5.861 ,   7.23  ,   6.561 ,   8.6931,  10.414 ,  11.664 , 12.404 ],
       [ 10.8723,  10.8459,   7.1286,   9.321 ,   6.212 ,   9.5172, 5.861 ,   4.82  ,   6.561 ,   5.7954,   7.8105,   4.6656, 4.9616],
       [ 21.7446,  25.3071,  24.9501,  24.856 ,  24.848 ,  25.3792, 26.3745,  19.28  ,  17.496 ,  23.1816,  23.4315,  20.9952, 22.3272],
       [  7.2482,   3.6153,   7.1286,   6.214 ,   6.212 ,   3.1724, 5.861 ,   4.82  ,   6.561 ,   5.7954,   7.8105,   6.9984, 7.4424]
       ])
'''


shipments = _iter_to_array(data.shipments().values())/1000 # kpcs to Mpcs
'''
array([3.359, 3.246, 3.24 , 2.985, 2.925, 2.823, 2.733, 2.308, 2.205, 2.686, 2.712, 2.674, 2.68 ])
# unit Mpcs
'''

#%%
'''
problem statement:
[        ]    [P5               ]   [K5             ]                [P5*K5               ]
[   R    ]    [   P7            ]   [  K7           ]   [       ]    [     P7*K7          ]
[        ]  = [      P10        ] @ [    K10        ] @ [   R   ] =  [          ...       ] @ R
[--------]    [         ...     ]   [       ...     ]   [       ]    [                    ]
[   S    ]    [             P250]   [           K250]                [                    ] 
              [1  1  1  ... 1   ]                                    [K5   K7  ...    K250]

   RS       =                                                     =           PKK           @ R

RS = PKK @ R
Constraint: K non-negative, K5<K7, K7<K10,...,K150<K250 
Goal: solve K, then solve P

strategy:

K0T , residual = nnls(R.T, S.T)
K0 = K0T.T

res = minimize(loss_func, K0, constraints)
K = res.x

note:
PK = PKK[:-1,:] appears to be identity matrix
As a result,

P = 1/K

revising strategy:
applying PK as identity matrix,

S = K @ R

'''

R = revenue_matrix
S = shipments

#%% initial guess uses nnls
# https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.nnls.html
def initial_guess():
    K0T , residual = nnls(R.T, S.T)
    return K0T.T

K0 = initial_guess()
'''
array([0.00832589, 0.00595463, 0.        , 0.00381002, 0.02956118, 0.01783495, 0.        , 0.        , 0.04144655, 0.00394519, 0.02079567, 0.04415343])
'''

# https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.LinearConstraint.html#scipy.optimize.LinearConstraint
# https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html#scipy.optimize.minimize

def loss_func(K)->float:
    delta = K @ R - S
    return delta @ delta.T

nT, nQ = R.shape # 12, 13

def constraints(nT):
    c = np.zeros([nT, nT])
    c[0,0]=1
    for i in range(1, nT):
        c[i, i-1]=  1
        c[i, i]  = -1
    lb = np.zeros(nT)
    lb[1:] = -np.inf
    ub = np.zeros(nT)
    ub[0] = np.inf
    return LinearConstraint(c, lb, ub)

lc = constraints(nT)


res = minimize(loss_func, K0, constraints=lc)
assert res.success
K = res.x
'''
array([0.00573835, 0.00573835, 0.00573835, 0.00573835, 0.00704866, 0.00704866, 0.00704866, 0.00704866, 0.02318026, 0.02318026, 0.02318026, 0.0588953 ])
'''

# invariant: PK is identity matrix
P = 1/K
'''
array([174.2660776 , 174.2660776 , 174.2660776 , 174.2660776 , 141.87086688, 141.87086688, 141.87086688, 141.87086688,  43.14014724,  43.14014724,  43.14014724,  16.97928415])
unit: K NTD
'''

# shipment (technology by quarter)
Stq = np.diag(K) @ R
'''
array([[0.29114903, 0.41491724, 0.16362565, 0.        , 0.        , 0.        , 0.        , 0.        , 0.        , 0.        , 0.        , 0.        , 0.        ],
       [0.72787258, 0.60163   , 0.71586221, 0.64184609, 0.62381619, 0.63715212, 0.45403845, 0.29041797, 0.27609504, 0.38244448, 0.16433778, 0.        , 0.        ],
       [0.        , 0.        , 0.        , 0.        , 0.00891166, 0.01820435, 0.03363248, 0.04148828, 0.0501991 , 0.09976813, 0.08963879, 0.17402354, 0.27047834],
       [0.29114903, 0.26969621, 0.36815771, 0.32092304, 0.33864307, 0.36408692, 0.36995726, 0.31807682, 0.20079639, 0.33256042, 0.34361535, 0.28111495, 0.25624264],
       [0.        , 0.02548303, 0.02512355, 0.0219002 , 0.02189315, 0.02236118, 0.02065611, 0.01698728, 0.01541543, 0.02042491, 0.03670239, 0.06577249, 0.0699453 ],
       [0.28099567, 0.28031336, 0.30148262, 0.30660276, 0.30650408, 0.29069534, 0.33049773, 0.30577102, 0.30830854, 0.34722351, 0.34867271, 0.37819181, 0.34972649],
       [0.17881543, 0.20386426, 0.20098841, 0.19710178, 0.21893149, 0.17888944, 0.20656108, 0.18686007, 0.18498512, 0.20424912, 0.22021434, 0.18087434, 0.19234957],
       [0.12772531, 0.12741517, 0.12561776, 0.13140118, 0.13135889, 0.15652826, 0.14459276, 0.13589823, 0.12332342, 0.1633993 , 0.14680956, 0.1479881 , 0.15737692],
       [0.25202278, 0.16760722, 0.16524283, 0.21606324, 0.2159937 , 0.22061121, 0.13585953, 0.16759331, 0.15208571, 0.20150835, 0.24139927, 0.2703746 , 0.28752799],
       [0.25202278, 0.25141082, 0.16524283, 0.21606324, 0.1439958 , 0.22061121, 0.13585953, 0.11172887, 0.15208571, 0.1343389 , 0.18104945, 0.10814984, 0.1150112 ],
       [0.50404557, 0.58662526, 0.5783499 , 0.57616864, 0.5759832 , 0.58829655, 0.61136787, 0.44691549, 0.4055619 , 0.53735561, 0.54314835, 0.48667428, 0.51755039],
       [0.4268849 , 0.21292417, 0.41984102, 0.36597538, 0.36585759, 0.18683944, 0.34518534, 0.28387534, 0.38641205, 0.34132181, 0.46000173, 0.41217285, 0.43832237]])
unit Mpcs
# 0.29114903 means 0.29114903 Mpcs for 2021Q1 5nm
'''
# invariant: np.sum(Stq,0) = S
_S_diff = np.abs(np.sum(Stq,0) - S)
print('lstsq error. max difference (M pcs) in shipment of some quarter', np.max(_S_diff), '.improve it to 0 ideally')

# wafer price by technology
wafer_price = { tech : price for price, tech in zip(P, data.technology)}
print('wafer price (K NTD)',wafer_price)

'''
{'5nm': 174.26607759869134,
 '7nm': 174.26607759845757,
 '10nm': 174.26607759939,
 '16nm': 174.26607759932566,
 '20nm': 141.87086687980448,
 '28nm': 141.8708668804317,
 '40/45nm': 141.87086688136566,
 '65nm': 141.8708668814012,
 '90nm': 43.14014723998238,
 '0.11/0.13um': 43.140147240173974,
 '0.15/0.18um': 43.14014724000278,
 '0.25um+': 16.979284149443302}

# unit K NTD
'''
